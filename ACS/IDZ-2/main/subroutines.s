# подпрограммы

.text
# Вычисляет π с использованием формулы Виета
# Вход: N (целое число - количество итераций), передается через стек на 0(sp)
# Выход: Вычисленное значение π, возвращается в fa0

.globl COMPUTE_PI
COMPUTE_PI:
	# Выделяем память на стеке для локальных данных
 	addi sp sp -24
 	sw ra 16(sp)

   	# Загрузка параметра N из стека
  	lw t0 24(sp)

 	li t1 2
 	fcvt.d.w ft1 t1

    	# 'a' = sqrt(2.0)
    	fsqrt.d ft0 ft1      	# ft0 = sqrt(2.0)
    	fsd ft0 8(sp)        	# Сохраняем 'a' на стеке 8(sp)

    	# 'p' = a / 2.0
    	fdiv.d ft2 ft0 ft1  	# ft2 = a / 2.0
    	fsd ft2 0(sp)        	# Сохраняем 'p' на стеке 0(sp)

    	# 'i' = 1
    	li t1 1
    	sw t1 -4(sp)         	# Сохраняем 'i' на стеке -4(sp)

loop_start:
    	# Загрузка 'i' в t1
    	lw t1 -4(sp)
    	# Сравнение 'i' и 'N' (t0)
    	bgt t1 t0 loop_end  	# Если i > N => выход из цикла

    	# Вычисление a = sqrt(2.0 + a)
    	fld ft0 8(sp)        	# Загружаем 'a' в ft0
    	fadd.d ft2 ft1 ft0  	# ft2 = 2.0 + a
    	fsqrt.d ft0 ft2      	# ft0 = sqrt(2.0 + a)
    	fsd ft0 8(sp)        	# Сохраняем новое значение 'a' на стеке 8(sp)

    	# Вычисление p *= a / 2.0
    	fld ft3 0(sp)        	# Загружаем 'p' в ft3
    	fdiv.d ft2 ft0 ft1  	# ft2 = a / 2.0
    	fmul.d ft3 ft3 ft2  	# ft3 = p * (a / 2.0)
    	fsd ft3 0(sp)        	# Сохраняем обновленное значение 'p' на стеке 0(sp)

    	# Инкремент i
    	lw t1 -4(sp)         	# Загружаем 'i' в t1
    	addi t1 t1 1        	# t1 = t1 + 1
    	sw t1 -4(sp)         	# Сохраняем обновленное значение 'i' на стеке -4(sp)

    	# Переход на следующую итерацию цикла
    	j loop_start

loop_end:
    	# После цикла вычисляем pi = 2.0 / p
    	fld ft2 0(sp)        	# Загружаем 'p' в ft2
    	fdiv.d fa0 ft1 ft2  	# fa0 = 2.0 / p (вычисленное значение π)

    	# Эпилог
    	lw ra 16(sp)         	# Восстанавливаем адрес возврата
    	addi sp sp 24       	# Восстанавливаем стеек
    	ret                   	# Выход из подпрограммы
